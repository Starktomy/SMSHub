package service

import (
	"context"
	"testing"
	"time"

	"github.com/Starktomy/smshub/internal/models"
	"github.com/Starktomy/smshub/internal/repo"
	"go.uber.org/zap"
)

func TestSchedulerService_CRUD(t *testing.T) {
	db := setupTestDB(t)
	logger := zap.NewExample()
	svc := NewSchedulerService(logger, db, nil, nil)
	ctx := context.Background()

	// 1. Create
	task := &models.ScheduledTask{
		Name:         "Test Task",
		Enabled:      true,
		IntervalDays: 1,
		PhoneNumber:  "10086",
		Content:      "Test Content",
	}
	if err := svc.Create(ctx, task); err != nil {
		t.Fatalf("Create failed: %v", err)
	}
	if task.ID == "" {
		t.Error("Expected ID to be generated")
	}

	// 2. GetById
	fetched, err := svc.GetById(ctx, task.ID)
	if err != nil {
		t.Fatalf("GetById failed: %v", err)
	}
	if fetched.Name != task.Name {
		t.Errorf("Expected Name %s, got %s", task.Name, fetched.Name)
	}

	// 3. Update
	task.Name = "Updated Task"
	if err := svc.Update(ctx, task); err != nil {
		t.Fatalf("Update failed: %v", err)
	}
	updated, _ := svc.GetById(ctx, task.ID)
	if updated.Name != "Updated Task" {
		t.Errorf("Expected Name 'Updated Task', got %s", updated.Name)
	}

	// 4. GetAll
	tasks, err := svc.GetAll(ctx)
	if err != nil {
		t.Fatalf("GetAll failed: %v", err)
	}
	if len(tasks) != 1 {
		t.Errorf("Expected 1 task, got %d", len(tasks))
	}

	// 5. Delete
	if err := svc.Delete(ctx, task.ID); err != nil {
		t.Fatalf("Delete failed: %v", err)
	}
	_, err = svc.GetById(ctx, task.ID)
	if err == nil {
		t.Error("Expected error after delete, got nil")
	}
}

func TestSchedulerService_ShouldExecuteTask(t *testing.T) {
	svc := &SchedulerService{}
	now := time.Now()

	tests := []struct {
		name     string
		task     models.ScheduledTask
		expected bool
	}{
		{
			name: "Never run before",
			task: models.ScheduledTask{
				LastRunAt: 0,
			},
			expected: true,
		},
		{
			name: "Interval met",
			task: models.ScheduledTask{
				LastRunAt:    now.AddDate(0, 0, -2).UnixMilli(), // 2 days ago
				IntervalDays: 1,
			},
			expected: true,
		},
		{
			name: "Interval not met",
			task: models.ScheduledTask{
				LastRunAt:    now.AddDate(0, 0, -1).UnixMilli(), // 1 day ago
				IntervalDays: 2,
			},
			expected: false,
		},
		{
			name: "Failed retry after 1 day",
			task: models.ScheduledTask{
				LastRunAt:     now.AddDate(0, 0, -1).UnixMilli(), // 1 day ago
				IntervalDays:  7,
				LastRunStatus: models.LastRunStatusFailed,
			},
			expected: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := svc.shouldExecuteTask(tt.task, now); got != tt.expected {
				t.Errorf("shouldExecuteTask() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestSchedulerService_UpdateLastRun(t *testing.T) {
	db := setupTestDB(t)
	// 需要创建 TextMessageRepo 否则 setupTestDB 中的 AutoMigrate 不足以支持 UpdateLastRun 可能的依赖（虽然这里其实只依赖 ScheduledTaskRepo）
	// 但 NewSchedulerService 内部创建了 repo.NewScheduledTaskRepo(db)

	logger := zap.NewExample()

	// Create repo manually or trust NewSchedulerService
	taskRepo := repo.NewScheduledTaskRepo(db)
	// We don't need full service for this specific test if we just test the method,
	// but using service method is better integration test.

	svc := NewSchedulerService(logger, db, nil, nil)
	ctx := context.Background()

	task := &models.ScheduledTask{
		Name: "Test Task",
	}
	if err := taskRepo.Create(ctx, task); err != nil {
		t.Fatalf("Failed to prepare task: %v", err)
	}
	// Need to get ID back if generated by DB? No, UUID is generated in Create method of service usually.
	// Repo Create might not gen UUID if not provided?
	// Let's use service.Create to be safe about ID generation
	task2 := &models.ScheduledTask{Name: "Test Task 2"}
	svc.Create(ctx, task2)

	// Update status
	err := svc.UpdateLastRun(ctx, task2.ID, "msg-123", models.LastRunStatusSuccess)
	if err != nil {
		t.Fatalf("UpdateLastRun failed: %v", err)
	}

	updated, _ := svc.GetById(ctx, task2.ID)
	if updated.LastRunStatus != models.LastRunStatusSuccess {
		t.Errorf("Expected status Success, got %s", updated.LastRunStatus)
	}
	if updated.LastMsgId != "msg-123" {
		t.Errorf("Expected LastMsgId 'msg-123', got %s", updated.LastMsgId)
	}
}
